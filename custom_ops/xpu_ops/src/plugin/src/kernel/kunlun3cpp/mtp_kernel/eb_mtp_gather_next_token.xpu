#include "xpu/kernel/cluster.h"
#include "xpu/kernel/cluster_debug.h"
#include "xpu/kernel/cluster_primitive.h"
namespace xpu3 {
namespace plugin {
#define MAX_LM_SIZE 28672
// One core has 32KB LMï¼ˆgroup LM), MAX_LM_SIZE = (32 - 4)KB / 2 = 30720, 4KB is
// the stack space
#define MAX_BATCH 512
#define ALIGNMENT 64

template <typename TX, typename TY>
static __device__ void do_memcpy_1d(_global_ptr_ TX* src,
                                    _global_ptr_ TY* dst,
                                    int64_t copy_size) {
#ifdef __XPU3__
  constexpr int buf_size = 2048;
#else
  constexpr int buf_size = 512;
#endif
  __group_shared__ __simd__ float double_lmx[2][buf_size];
  int64_t pingpong = 0;
  for (int64_t i = 0; i < copy_size; i += buf_size) {
    int real_size = min<int64_t>(buf_size, copy_size - i);
    _group_shared_ptr_ float* lmx = double_lmx[pingpong];
    GM2GSM(src + i, lmx, real_size * sizeof(TX));
    if (!xpu_std::is_same<TX, TY>::value) {
      primitive_cast_gsm<TX, float>(
          (_group_shared_ptr_ TX*)lmx, lmx, real_size);
      primitive_cast_gsm<float, TY>(
          lmx, (_group_shared_ptr_ TY*)lmx, real_size);
    }
    GSM2GM_ASYNC((_group_shared_ptr_ TY*)lmx, dst + i, real_size * sizeof(TY));
    pingpong = 1 - pingpong;
  }
  mfence();
}

template <typename TX, typename TY>
__global__ void eb_mtp_gather_next_token(TX* src,
                                         TY* dst,
                                         int* encoder_seqs_lods,
                                         int* decoder_seqs_lods,
                                         int* encoder_batch_map,
                                         int* decoder_batch_map,
                                         int en_batch,
                                         int de_batch,
                                         int64_t copy_size) {
  int tid = core_id() * cluster_num() + cluster_id();
  int nthreads = core_num() * cluster_num();
  __group_shared__ int local_lods_en[MAX_BATCH + 1];
  __group_shared__ int local_lods_de[MAX_BATCH + 1];
  __group_shared__ int local_map_en[MAX_BATCH];
  __group_shared__ int local_map_de[MAX_BATCH];
  GM2GSM_ASYNC(encoder_seqs_lods, local_lods_en, (en_batch + 1) * sizeof(int));
  GM2GSM_ASYNC(decoder_seqs_lods, local_lods_de, (de_batch + 1) * sizeof(int));
  if (en_batch > 0) {
    GM2GSM_ASYNC(encoder_batch_map, local_map_en, en_batch * sizeof(int));
  }
  if (de_batch > 0) {
    GM2GSM_ASYNC(decoder_batch_map, local_map_de, de_batch * sizeof(int));
  }
  mfence();
  int encoder_len_total = en_batch > 0 ? local_lods_en[en_batch] : 0;
  int output_len = en_batch + local_lods_de[de_batch];
  int start = 0;
  int end = 0;
  partition(tid, nthreads, output_len, 1, &start, &end);
  for (int i = start; i < end; i++) {
    int len = 0;
    int enc_idx = 0, dec_idx = 0;
    bool is_enc;
    while (i >= len) {
      if (enc_idx >= en_batch) {
        len += local_lods_de[dec_idx + 1] - local_lods_de[dec_idx];
        dec_idx++;
        is_enc = false;
        continue;
      }
      if (dec_idx >= de_batch) {
        len += 1;
        enc_idx++;
        is_enc = true;
        continue;
      }
      if (local_map_en[enc_idx] < local_map_de[dec_idx]) {
        len += 1;
        enc_idx++;
        is_enc = true;
      } else {
        len += local_lods_de[dec_idx + 1] - local_lods_de[dec_idx];
        dec_idx++;
        is_enc = false;
      }
    }
    _global_ptr_ TX* cur_src = nullptr;
    _global_ptr_ TY* cur_dst = dst + i * copy_size;
    if (is_enc) {
      cur_src = src + (local_lods_en[enc_idx] - 1) * copy_size;
    } else {
      cur_src = src + (encoder_len_total + local_lods_de[dec_idx] - (len - i)) *
                          copy_size;
    }
    do_memcpy_1d<TX, TY>(cur_src, cur_dst, copy_size);
  }
}
#define _XPU_DEF__EB_MTP_GATHER_NEXT_TOKEN(TX, TY)           \
  template __global__ void eb_mtp_gather_next_token<TX, TY>( \
      TX * src,                                              \
      TY * dst,                                              \
      int* encoder_seqs_lods,                                \
      int* decoder_seqs_lods,                                \
      int* encoder_batch_map,                                \
      int* decoder_batch_map,                                \
      int en_batch,                                          \
      int de_batch,                                          \
      int64_t copy_size);

_XPU_DEF__EB_MTP_GATHER_NEXT_TOKEN(float16, float16);
_XPU_DEF__EB_MTP_GATHER_NEXT_TOKEN(bfloat16, bfloat16);
_XPU_DEF__EB_MTP_GATHER_NEXT_TOKEN(float, float);
_XPU_DEF__EB_MTP_GATHER_NEXT_TOKEN(float16, float);
_XPU_DEF__EB_MTP_GATHER_NEXT_TOKEN(float, float16);
_XPU_DEF__EB_MTP_GATHER_NEXT_TOKEN(bfloat16, float16);
_XPU_DEF__EB_MTP_GATHER_NEXT_TOKEN(float16, bfloat16);
_XPU_DEF__EB_MTP_GATHER_NEXT_TOKEN(bfloat16, float);
_XPU_DEF__EB_MTP_GATHER_NEXT_TOKEN(float, bfloat16);
}  // namespace plugin
}  // namespace xpu3
